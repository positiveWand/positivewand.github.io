---
layout: post
title: "숫자의 표현(정수)"
toc: true
---
이번 포스트에서는 정수를 비트로 인코딩하기 위한 방법들을 살펴본다. 이전 포스트에서는 정보를 비트로 인코딩할 수 있다는 것을 알아보았다. 그렇다면 대표적인 정보인 숫자도 비트로 인코딩할 수 있을 것이다. 이번 포스트에서는 그 중 정수 집합의 숫자들을 비트로 인코딩하는 방법들을 알아보고자한다.

# 2진법(binary)
비트는 0과 1의 조합으로 정보를 표현한다. 따라서 0과 1을 이용해 수를 표현하는 **2진법(binary)**을 이용한다면 어렵지 않게 정수를 비트로 표현할 수 있다. 2진법을 이용해 표현한 수를 2진수(binary number)라고한다.

2진수의 예시를 들어보자. 2진수인 **101101**을 우리가 익숙한 10진수로 바꿔본다면 **32 + 8 + 4 + 1 = 45**가 된다.
각 자릿수에 해당하는 2의 거듭제곱을 자릿수가 0이면 제외하고, 자릿수가 1이면 더하여 10진수로 변환할 수 있다.

또 컴퓨터 내에서는 사람들이 보통 사용하는 것과는 다르게 필요한만큼 자릿수를 사용하는 것이 아니라 일정한 개수의 비트를 사용해 숫자를 표현하기 때문에 앞에 여분의 0이 추가되는 경우가 존재한다. 컴퓨터가 숫자를 10개의 비트로 표현한다면 앞의 101101은 컴퓨터의 저장공간에 0000101101과 같이 앞에 여분의 0이 4개가 존재하게된다.

## 문제점 및 한계
하지만 이렇게 2진법을 이용해 정수를 표현하는 방법에는 문제가 있다. 정수의 반절을 차지하고 있다고 볼 수 있는 음수를 표현하지 못한다는 점이다. 우리 사람들이 사용할 때는 숫자 앞에 부호(+, -)를 붙여 양수와 음수를 구별하는 반면 2진법을 이용한 표현방법으로는 그렇게 표현하지 못한다.

> 정수를 **2진법(binary)**을 이용해 2진수로 표현할 수 있다. 하지만 이런 방식은 **음수를 표현하지 못한다**는 문제점이 있다.

# 부호와 크기(sign & magnitude)
음수를 표현하지 못한다는 2진법의 문제점을 보완하기 위해 **부호와 크기(sign & magnitude)**를 사용할 수 있다. 이 방법은 사람들이 사용하는 방법과 비슷하다. 2진법 표현법을 이용해 정수의 **크기(magnitude)** 혹은 절대값을 표현하며 여기에 비트 1개를 추가하여 정수의 **부호(sign)**를 표현한다. 부호는 **+ 기호**와 **- 기호**를 가지므로 1개의 비트를 이용해 인코딩하는 것이 가능하다.

이것도 마찬가지로 표현한 숫자의 예시를 들어보자. 비트 조합 **101101**을 부호와 크기를 이용한 방법으로 디코딩한다면 **-(8 + 4 + 1) = -13**이 된다.
부호와 크기 표현법에서는 가장 왼쪽의 비트, 즉 LSB를 이용해 부호를 표현한다. 그것이 0이면 양수, 1이면 음수이다. 그리고 나머지 비트들은 2진법으로 숫자의 절대값을 표현한다.
**+13**을 부호와 크기 표현법으로 비트로 표현한다면 **001101**이 되는 것이다.

## 문제점 및 한계
부호와 크기 표현법을 이용한 정수 표현은 다음과 같은 문제점이 있다.

1. 0을 표현하는 방법이 2가지(부호는 다르지만 크기가 0인 2가지 경우)가 생긴다. 이것은 가능한 비트 조합들을 완전히 활용하지 못한다는 것이기 때문에 낭비다.
2. 정수 관련 연산 하드웨어를 구현하는 것이 복잡하다. 구체적으로 설명하면 XOR, AND 논리 연산을 통해 덧셈 회로를 구성할 수 없어 구현이 복잡해진다.

> 정수를 **부호와 크기(sign & magnitude)** 표현법을 이용해 부호와 크기를 비트로 표현할 수 있다. 하지만 이런 방식은 **비효율적**이다.

# 1의 보수(1's complement)
정수를 표현하는 다른 방법으로 **1의 보수(1's complement)** 표현법이 있다. 1의 보수 표현법에서는 양수의 모든 비트를 뒤집는 것으로 음수를 표현한다. 0을 1로 1을 0으로 뒤집는 것이다, 이것은 논리 연산 중 하나인 NOT 연산에 해당한다. 1의 보수 표현법은 보호와 크기 표현법과 비슷하게 MSB로 부호를 표현한다고 볼 수 있다. 양수인 경우 MSB가 0, 음수인 경우 MSB가 1이다.

예시를 들어보자. 비트 조합 **01101**은 1의 보수 표현법에서는 **8 + 4 + 1 = 13**이 된다.
여기서 각 비트를 뒤집으면 **10010**, 즉 **-13**을 얻을 수 있다.

## 문제점 및 한계
1의 보수 표현법을 이용한 정수 표현은 부화와 크기와 비슷한 문제를 가지고 있다.

1. 0을 표현하는 방법이 2가지(양수 0과 음수 0)가 존재한다.
2. 정수 관련 연산 하드웨어를 구현하는 것이 복잡하다. 덧셈 연산 시 MSB 자리에서 발생하는 올림을 LSB 자리에 더해주는 추가적인 회로가 추가되어야한다. 다시 말해, 순환 올림을 위한 회로 추가가 필요해진다.

> **1의 보수(1's complement)**에서는 양수의 비트들을 모두 뒤집는 방식으로 음수를 표현하여 정수를 표현할 수 있다. 하지만 이런 방식은 **비효율적**이다.

# 2의 보수(2's complement)
이번 포스트에서 소개할 정수를 표현하는 마지막 방법으로 **2의 보수(1's complement)** 표현법이 있다. 1의 보수를 소개한 이유가 사실은 2의 보수를 소개하기 위해서인데 이는 1의 보수 표현법을 조금만 바꾸면 2의 보수 표현법이 되기 때문이다. 2의 보수 표현법에서는 양수의 모든 비트를 뒤집고 거기에 1을 더하는 것으로 음수를 표현한다. 이와 같은 방법을 통해 정수를 표현한다면 이전에 소개한 표현법들이 가지는 문제들을 해결할 수 있다.

먼저, 0을 표현하는 방식이 1개이다. 4개 비트를 사용한다고 할 경우 정수 0은 0000으로 표현되는데, 음의 0을 만들보려고하면 비트를 모두 뒤집은 값인 1111에 1을 더해주는데 그 결과는 0000이다. 본래라면 1111에 1을 더하면 10000이 되어야하지만 4개 비트만을 사용하기 때문에 MSB에서 올려진 값은 무시된다. 이전 방법들과는 다르게 정수 0이 양의 0과 음의 0, 2개로 존재하지 않는 것이다.

하드웨어 구현에 있어서도 단순해진다. 2의 보수 표현법을 이용해 표현된 숫자들을 더해보면 양의 정수를 더하는데 사용한 회로를 그대로 사용할 수 있다. 이전 방법들과는 다르게 추가적인 회로가 필요없어 하드웨어 설계가 단순해지고 생산 비용도 줄어든다.

따라서 현재 컴퓨터들은 2의 보수를 이용해 정수를 표현한다.

> **2의 보수(2's complement)**에서는 양수의 비트들을 모두 뒤집은 값에 1을 더하여 음수를 표현하여 정수를 표현할 수 있다. **현재 컴퓨터들은 이 방법을 이용해 정수를 표현하고 있다.**

# 오버플로우(overflow)
정수 집합은 무한히 많은 원소를 가진다. 따라서 유한한 비트들을 이용해 정수 집합 전체를 인코딩하는 것은 불가능하다. 정수를 저장하는데만 사용한다면 단순히 인코딩하는데 사용하는 비트 개수를 필요한만큼 늘림으로써 문제가 발생하지 않는다. 하지만 그것들을 이용해 다양한 연산을 수행하는 경우 문제가 발생한다. 컴퓨터는 정수를 저장하기 위해 정해진 개수의 비트를 사용하는데 이것들을 이용해 덧셈, 곱셈 등의 연산을 수행하다보면 사전에 정의된 비트 개수를 넘어서는 경우가 자연스레 발생한다. 이런 현상을 비트 조합의 표현 범위를 넘어섰다고 하여 **오버플로우(overflow)** 현상이라고 한다.

오버플로우가 발생하면 계산된 실제결과가 정해진 비트 개수로 잘린 형태를 띄게 된다. 개발자는 이것을 항상 염두하여 연산을 수행해야만한다. 실제로 이런 상황을 생각치 못해 경제적, 사회적인 문제가 발생하기도하였다.

> **오버플로우(overflow) 현상**은 정수라는 무한 집합을 유한한 공간에 전사(mapping)시키면서 발생하는 문제이다. 개발자는 이런 문제가 발생할 수 있음을 항상 염두하여야한다.

# 결론
정수를 표현하는 방법으로 2진법, 부호와 크기 표현법, 1의 보수 표현법, 2의 보수 표현법을 살펴보았다. 2진법은 음의 정수값들은 표현하지 못했고 부호와 크기 표현법과 1의 보수 표현법은 음수를 표현할 수 있지만 비트를 효율적으로 사용하지 못하고 정수 연산 하드웨어의 구현을 복잡하게 한다는 문제가 존재했다. 따라서 현재 컴퓨터들은 부호가 없는 정수의 경우 2진법, 부호가 있는 정수의 경우 2의 보수 표현법을 이용해 정수를 표현하고 있다.

# 참고
- 조너선 스타인하트, "한 권으로 읽는 컴퓨터 구조와 프로그래밍", 오현석, 책만(2021)
- Randal E Bryant, David R O'Hallaron, "컴퓨터 시스템(3판)", 김형신, 퍼스트북(2016)