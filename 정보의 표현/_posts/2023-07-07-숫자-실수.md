---
layout: post
title: "숫자의 표현(실수)"
toc: true
mathjax: true
---
이번 포스트에서는 실수를 비트로 인코딩하기 위한 방법들을 살펴본다. 숫자를 비트로 인코딩하는 방법에서 정수보다 더 넓은 범위의 수인 실수를 표현하는 방법에 대해 알아보자. 실수를 표현하는 방식으로는 고정소수점 표현법과 부동소수점 표현법 2가지가 있다.

# 고정소수점(fixed-point) 표현법
정수를 표현하는 방법과 비슷하게 실수의 모든 자릿수를 비트를 이용해 표현할 수 있다. 하지만 컴퓨터에서는 사용하는 표현하기 위한 비트의 개수가 정해져있다, 따라서 유한한 비트들을 이용해 소수점 오른쪽 부분의 비트 개수와 왼쪽 부분의 개수를 비트 개수를 정해놓고 실수를 표현하는 것을 **고정소수점(fixed-point) 표현법**이라고한다.

예시를 들어보자, 소수점 오른쪽 부분에는 6개의 비트, 소수점 왼쪽 부분에는 4개의 비트를 사용해보자. 그러면 비트 조합 **100110.0100** 은 **32 + 4 + 2 + 1/4 = 38.25** 가 된다. 보면 알겠지만 실수는 매우 긴 경우가 많은데 정확한 수 표현을 위해서는 매우 많은 비트가 필요해질 것이라는 것을 알 수 있다.

## 문제점 및 한계
고정소수점 표현법은 유한한 비트를 사용하여 실수를 표현하기 때문에 무한한 길이를 가지는 실수들을 정확히 표현하지 못한다. 따라서 근사값을 이용해야하며 표현 정확도를 높이기 위해서는 많은 수의 비트가 필요하다.

또 실수 관련 계산을 수행할 때 매우 큰 수와 매우 작은 수를 사용해야할 경우가 많은데 고정소수점 표현법은 넓은 범위의 수를 표현하는데 매우 많은 비트가 필요하다. 단순히 실수의 길이가 길어짐에 따라 그에 비례하여 더 많은 비트가 필요해진다. 이런 문제를 해결하고자 컴퓨터과학자들은 부동소수점이라는 표현법을 고안했다.

> **고정소수점(fixed-point)** 표현법은 실수의 자릿수를 그대로 비트를 이용해 나타낸다. 하지만 이 때문에 **매우 많은 비트를 필요**로 한다.

# 부동소수점(floating-point) 표현법
**부동소수점(floating-point)** 표현법은 고정소수점 표현법의 넓은 범위의 수를 표현하는데 필요한 비트가 많다는 문제를 해결하기 위해 **과학적 표기법(scientific notation)**을 2진수에 적용한다. 위치에 기반을 둔 표현법이 넓은 범위를 표현하는데 효율적이지 못하므로 과학적 표기법을 도입한 것이다.

## 과학적 표기법(scientific notation)
**과학적 표기법(scientific notation)** 은 너무 크거나 작은 숫자들을 과학자, 수학자들이 편하게 표현하기 위해 고안된 방법이다. 이 표현법은 컴퓨터에서 실수를 효율적으로 저장하는데에도 사용될 수 있다.

2진수를 위한 과학적 표기법은 아래와 같은 형태로 숫자를 표현한다.

$$ M \times 2^e (M \in \mathbb{R}, e \in \mathbb{Z}, 1 \le M \lt 2) $$

$M$(가수)과 $e$(지수)만을 이용해 수를 표현하는 과학적 표기법을 사용할 경우 고정소수점 표현법과 비교했을 때 같은 비트 개수를 통해 더 넓은 범위의 수를 표현할 수 있다.

이것을 예시로 비교해보면 8개의 비트를 이용해 실수를 표현한다고 할 때, 고정소수점 표현법(왼쪽 = 비트 6개, 오른쪽 = 비트 2개) **000000.00**, **111111.11**와 같이 소수점 위 6자리의 수, 소수점 아래 2자리의 수만을 표현하는 반면, 과학적 표기법(가수 = 비트 6개, 지수 = 비트 2개)의 경우 **0.000111111**, **1111110000.**과 같이 고정소수점 표현법으로는 표현하지 못한 범위의 수까지 표현하는 것을 확인할 수 있다.

참고로 부동소수점의 부동은 "떠다니면서 움직인다"라는 뜻으로 고정소수점 표현법과는 다르게 지수값에 의해 소수점이 움직이기 때문에, 다시 말해 정수부와 소수부의 비트 수가 유동적으로 변하기 때문에 이러한 이름이 붙었다.

> 부동소수점 표현법은 **과학적 표기법(scientific notation)**을 사용하여 표현 가능한 자릿수 또는 수의 범위를 (고정소수점 표현법과 비교했을 때) 늘릴 수 있다.

## IEEE 부동소수점 표현
이런 과학적 표기법에 기반하여 **부동소수점(floating-point)** 표현법이라는 방법이 고안되었고 최종적으로는 하드웨어 구현, 연산, 저장 측면을 모두 고려하여 **IEEE 754** 표준으로 부동소수점이 컴퓨터에서 표현, 처리되는 방법이 표준화되었다. 여기에서는 표준의 구체적인 내용은 다루지 않고 부동소수점 표현 형식, 해석법에 대해서 살펴본 후 무한한 실수를 표현함에 따라 필요한 수의 근사를 알아본다.

### 표현 형식
부동소수점 수의 비트 형식은 **부호(sign)**, **지수(exponent)**, **가수(mantissa)** 각각을 인코딩한 비트들을 이어붙인 형태이다.

- **부호 필드**: 부호를 인코딩
  - 실수가 양수인지 음수인지를 나타내는 비트 1개
- **지수 필드**: 지수 $e$를 인코딩
  - 과학적 표기법의 지숫값(=정수)를 나타낸 비트 조합
  - 원래의 지숫값($=e$) 대신 **편항된 지숫값($=e - Bias$ 또는 $=1- Bias$)**을 인코딩
  - 편향된 지숫값을 인코딩하는 이유는 부호 표현에 사용되는 비트를 아끼면서 지수 비트가 모두 0이거나 1일때 특별한 의미를 부여하기 위함(해석법 부분 참조)
- **가수 필드**: 가수 $M$을 인코딩
  - 과학적 표기법의 가숫값(=실수)를 나타낸 비트 조합
  - 경우에 따라 가숫값($=M$)을 그대로 사용하기도하고 선두 비트를 생략한 가숫값($=M-1$)을 인코딩

> 부동소수점 수의 비트 형식은 **3가지 필드(부호 필드, 지수 필드, 비율 필드)**로 구성된다.

### 해석법
위의 표현 형식에서 지수 필드와 비율 필드의 비트들이 인코딩하는 값이 달라지는 것을 알 수 있는데 이는 지수 필드의 값에 따라 디코딩하는 방식이 달라지기 때문이다. 지수 필드의 값에 따라 아래 3가지 경우로 나눠서 디코딩한다.

- **정규화 값(Normalized Values)**: 지수 필드의 비트가 모두 1이거나 모두 0이 경우가 아닌 경우
  - 가장 일반적인 인코딩 방식
  - 편향된 지숫값($= e - Bias$)과 선두 비트를 생략한 가숫값($=M-1$)을 인코딩
  - 선두 비트를 생략하여 가숫값 표현에 사용되는 비트 1개를 아낄 수 있음
  - 선두 비트를 생략한 것을 정규화하였다고 하여 정규화 값이라고 부른다
- **비정규화 값(Denormalized Values)**: 지수 필드의 비트가 모두 0인 경우
  - 정규화 값이 표현하지 못하는 0과 그 근처의 값들을 표현
  - 편향된 지숫값($=1-Bias$), 원래 가숫값($=M$)을 인코딩
  - 생략된 선두 비트가 없기 때문에 0과 그 근처의 값들을 표현하는 것이 가능
- **특수 값(Special Values)**: 지수 필드가 모두 1인 경우
  - 특수한 경우에 사용되는 값을 표현
  - 3가지 경우로 다시 나뉜다
    - **양의 무한대**: 부호가 양수이면서 가수 필드가 모두 0인 경우
    - **음의 무한대**: 부호가 음수이면서 가수 필드가 모두 0인 경우
    - **NaN(Not a Number)**: 가수 필드가 모두 0이 아닌 경우
  - 표현 가능한 범위를 벗어나는 경우 **양의 무한대**와 **음의 무한대**를 사용 가능하고 잘못된 연산의 결과로 **NaN**을 사용 가능

> 부동소수점 비트 형식은 지수 필드의 비트 조합에 따라 **3가지 경우(정규화 값, 비정규화 값, 특수 값)**로 나눠 해석할 수 있다.

## 수의 근사
실수 집합은 원소의 개수가 무한한 집합이다. 따라서 정수의 표현에서와 마찬가지로 한정된 비트를 이용해 수를 표현하기 때문에 문제가 발생한다. 하지만 정수는 이산적인 반면에 실수는 연속적이기 때문에 조금은 다른 문제가 발생한다. 바로 **표현한 수의 정확도 문제**이다.

정수는 이산적이기 때문에 비트에 의해 표현 가능한 수의 범위가 제한될 뿐 범위 내에서는 수를 정확히 표현한다. 하지만 실수는 연속적이기 때문에 표현 가능한 수의 범위가 제한되기도하면서 무한소수와 같은 수들은 정확히 표현하지 못한다. 가수를 표현하는 비트를 늘려 정밀도를 높여 오차를 줄일 수는 있지만 완전한 표현은 불가능하다. 따라서 표현하고자 하는 수 혹은 수끼리의 연산 결과를 불가피하게 부동소수점 표현법으로 표현 가능한 수로 **근사(rounding)** 해야만한다.

IEEE 부동소수점 표현에서는 실수를 가장 가까운 표현 가능한 수에 근사하게된다. 하지만 수가 표현 가능한 수들 사이의 정중앙에 위치할 경우에는 그 2개 중 짝수에 근사시키는 **짝수근사법(round-to-even)**을 이용해 근사하도록 한다. 굳이 짝수근사법을 사용하는 이유는 우리가 일반적으로 사용하는 반올림 기법과 같이 정중앙 값을 항상 올림하게 되면 실수 집합들의 평균이 상향 편향되는 문제가 발생하기 때문이다. 짝수근사법을 사용한다면 올림되는 값과 내림되는 값이 반으로 나뉘기 때문에 그런 통계적 편향 문제를 완화할 수 있다.

> 부동소수점 표현법은 연속적이고 무한한 실수 집합을 이산적이고 유한한 집합에 전사(mapping)하기 때문에 수의 **근사(rounding)**가 불가피하게 발생한다.

## 문제점 및 한계
부동소수점 표현법은 정수가 아닌 실수를 유한한 비트를 이용해 표현하기 때문에 표현하고자 하는 실수(실수 리터럴, 실수 연산 결과 등)를 표현 가능한 수로 근사하게된다. 따라서 컴퓨터에서 실수를 다루게 되는 경우 항상 수학적으로 정확한 연산 결과를 얻는 것은 불가능하다(사용하는 수가 표현가능한 수라면 근사 작업은 불필요).

간단한 예시로 $1.1 + 0.1 = 1.2$ 라는 등식은 수학적으로 참이다. 하지만 이것을 컴퓨터에서 수행하게 되면 $1.1 + 0.1 \neq 1.2$ 라는 결과를 얻을 수 있다. 이는 컴퓨터가 0.1이라는 상수를 부동소수점 표현법으로는 정확히 표현하지 못하기 때문이다.

이런 부동소수점 근사로 인해 실제로 문제가 발생한 사례가 있다. 미군의 패트리어트 미사일 시스템은 시간 관련 변수에 0.1을 누적해서 더하는 로직이 존재하였다. 0.1이 더해질때마다 근사 오차는 누적해서 커지게 되었고 그러다보니 장시간 구동으로 누적된 오차가 계산에 큰 오차를 발생시켜 시스템이 미사일 요격에 실패해 군 사상자가 발생했다. 이와 같이 부동소수점 연산의 오차를 충분히 고려하지 못한다면 치명적인 문제를 일으킬 수 있다.

따라서 부동소수점을 다룰 때는 근사로 인해 오차가 발생함을 항상 염두해야한다. 만약 정확한 값 저장/계산이 필요하다면 **높은 정밀도의 부동소수점 자료형을 사용**하거나 **숫자를 정수로 변환하는 작업을 수행**하는 것이 바람직하다.

> 부동소수점 관련 연산 수행 시 발생하는 오차를 항상 고려해야하며 오차를 줄이기 위해서는 **높은 정밀도의 부동소수점 자료형을 사용**하거나 **실수 대신 정수를 사용**하는 것이 좋다.

## 부동소수점에서의 오버플로우
정수를 사용할 시 연산 결과가 표현 가능한 범위를 넘어서는 경우 큰 수가 작은 수로 표현되는 오버플로우 현상이 발생한다. 부동소수점 표현법을 사용할 시에는 연산 결과가 표현 가능한 범위를 넘어설 경우 특수 값들(양의 무한대, 음의 무한대, NaN)을 이용해 그 결과를 표현한다. 다시 말해, 부동소수점 표현법 사용 시에는 **특수 값들을 이용해 오버플로우 현상을 표현**한다.

# 결론
실수를 표현하는 방법으로 **고정소수점 표현법**과 **부동소수점 표현법**이 있음을 알아보았다. 같은 비트 수를 사용한다고 할 때 고정소수점 표현법보다는 부동소수점 표현법이 넓은 범위의 수 표현이 가능해 범용적인 사용에 적합하다. 하지만 부동소수점 표현법은 실수를 정확히 표현하지 못한다는 문제가 있으므로 **항상 주의해서 사용**해야한다.

# 참조
- 조너선 스타인하트, "한 권으로 읽는 컴퓨터 구조와 프로그래밍", 오현석, 책만(2021)
- Randal E Bryant, David R O'Hallaron, "컴퓨터 시스템(3판)", 김형신, 퍼스트북(2016)
